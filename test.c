#include "processor.h"
#include "ememory.h"
#include <assert.h>
#include <stdio.h>

#define TEST_MEM_SIZE 128

// All tests below were generated by ChatGPT.
// This was done on purpose; basic functionality is important, and we can afford
// to discover edge cases as they come.

static struct ememory make_mem(char *data) {
    struct ememory mem = {};
    mem.data = data;
    init_ememory(&mem, TEST_MEM_SIZE);
    return mem;
}

/* ------------------- Basic allocation tests ------------------- */

void test_simple_alloc() {
    char data[TEST_MEM_SIZE];
    struct ememory mem = make_mem(data);

    struct eptr p = emalloc(&mem, 16);
    assert(p.ptr == STARTING_OFFSET);
    assert(p.size == 16);
    assert(mem.free_head == STARTING_OFFSET + 16);
}

void test_exact_fit_alloc() {
    char data[TEST_MEM_SIZE];
    struct ememory mem = make_mem(data);

    uint16_t full_size = TEST_MEM_SIZE - STARTING_OFFSET;
    struct eptr p = emalloc(&mem, full_size);
    assert(p.ptr == STARTING_OFFSET);
    assert(mem.free_head == 0); // No free space left
}

void test_multiple_allocations() {
    char data[TEST_MEM_SIZE];
    struct ememory mem = make_mem(data);

    struct eptr p1 = emalloc(&mem, 16);
    struct eptr p2 = emalloc(&mem, 32);

    assert(p1.ptr != p2.ptr);
    assert(mem.free_head == STARTING_OFFSET + 48);
}

/* ------------------- Free-before-head tests ------------------- */

void test_free_before_head_nonmerge() {
    char data[TEST_MEM_SIZE];
    struct ememory mem = make_mem(data);

    struct eptr p1 = emalloc(&mem, 16);
    struct eptr p2 = emalloc(&mem, 16);

    // Create free block before head but not adjacent
    struct eptr dummy = { .ptr = STARTING_OFFSET - 16, .size = 16 };
    efree(&mem, dummy);
    assert(mem.free_head == dummy.ptr);
}

void test_free_before_head_merge() {
    char data[TEST_MEM_SIZE];
    struct ememory mem = make_mem(data);

    struct eptr p1 = emalloc(&mem, 16);
    struct eptr p2 = emalloc(&mem, 16);

    efree(&mem, p1); // should merge with head if adjacent
    assert(mem.free_head == p1.ptr);
}

/* ------------------- Free-in-middle tests ------------------- */

void test_free_middle_merge_both() {
    char data[TEST_MEM_SIZE];
    struct ememory mem = make_mem(data);

    struct eptr p1 = emalloc(&mem, 16);
    struct eptr p2 = emalloc(&mem, 16);
    struct eptr p3 = emalloc(&mem, 16);

    efree(&mem, p1); // free head
    efree(&mem, p3); // free tail
    efree(&mem, p2); // free middle -> should merge all
}

void test_free_middle_merge_next_only() {
    char data[TEST_MEM_SIZE];
    struct ememory mem = make_mem(data);

    struct eptr p1 = emalloc(&mem, 16);
    struct eptr p2 = emalloc(&mem, 16);

    efree(&mem, p2); // merge with next if exists
}

void test_free_middle_merge_prev_only() {
    char data[TEST_MEM_SIZE];
    struct ememory mem = make_mem(data);

    struct eptr p1 = emalloc(&mem, 16);
    struct eptr p2 = emalloc(&mem, 16);

    efree(&mem, p1); // merge with previous if exists
}

/* ------------------- Free-at-tail tests ------------------- */

void test_free_at_tail_merge() {
    char data[TEST_MEM_SIZE];
    struct ememory mem = make_mem(data);

    struct eptr p1 = emalloc(&mem, 16);

    efree(&mem, p1); // tail merge
}

void test_free_at_tail_append() {
    char data[TEST_MEM_SIZE];
    struct ememory mem = make_mem(data);

    struct eptr p1 = emalloc(&mem, 16);
    struct eptr dummy = { .ptr = TEST_MEM_SIZE - 16, .size = 16 };

    efree(&mem, dummy); // append to tail without merge
}

/* ------------------- Allocate-After-Free tests ------------------- */

void test_alloc_after_free() {
    char data[TEST_MEM_SIZE];
    struct ememory mem = make_mem(data);

    struct eptr p1 = emalloc(&mem, 16);
    efree(&mem, p1);

    struct eptr p2 = emalloc(&mem, 16); // should reuse freed block
    assert(p2.ptr == p1.ptr);
}

/* ------------------- Main ------------------- */

int main() {
    test_simple_alloc();
    test_exact_fit_alloc();
    test_multiple_allocations();
    test_free_before_head_nonmerge();
    test_free_before_head_merge();
    test_free_middle_merge_both();
    test_free_middle_merge_next_only();
    test_free_middle_merge_prev_only();
    test_free_at_tail_merge();
    test_free_at_tail_append();
    test_alloc_after_free();

    printf("All tests passed.\n");
}
